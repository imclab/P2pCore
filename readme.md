P2pCore - A portable peer-to-peer framework
===========================================

P2pCore is a protable peer-to-peer framework written in Scala. It enables back-to-back RSA encrypted and direct datagram socket communication between devices which are located behind firewalls. For this purpose, "UDP hole punching" as described in this document http://www.brynosaurus.com/pub/net/p2pnat/ was being implemented. One major objective was to link two parties and enable communication without users having to log in to a service, or any accounts/usernames/passwords being required. 

P2pCore is highly portable and can be used, for example, in Gnome/GTK and Android environments. P2pCore uses binary message encoding.



System requirements
-------------------

To run (and build) this software the following 3rd party software packages needs to be installed: Scala 2.9.x, JDK 6 and Ant.

On Debian/Ubuntu you would install:

    apt-get install scala ant


Building from source
--------------------

To build the project, run:

    ./make

The `make` script will run three steps:

  1. compile P2pCore.java generated by the protocol buffer compiler using Ant
  2. compile all src/*.scala classes using Scalac
  3. run ./makejar script using the jar tool to create p2pCore.jar


Running the code 
----------------

A `run` script is used to invoke provided functionality. `run` combines the required libraries (three 3rp party libraries listed below as well as this projects p2pCore.jar) to the classpath and uses the scala runtime to execute specified classes.

Two instances of the software need to run in parallel, ideally on separate machines. Running both instances on the same machine or on separate machines but inside the same network (and behind the same firewall) is possible, but that would defeat the purpose of the project. Ideally you should use two machines, on two different networks and behind different firewalls.

### RelayBase

    ./run timur.p2pCore.RelayBase
  
RelayBase can be executed without arguments. RelayBase will establish communication with another instance of RelayBase by routing all communication through a relay server. RelayBase implements two methods and has only a dozen lines of code. Method 1: `connectedThread()` is called when a p2p connection has been established. Here a single call to `send("data")` is placed. Method 2: `receiveMsgHandler(str:String)` is called when a string message arrives from the other client. If the string message is "data", the application terminates. This is what is being displayed in the console, when looking at one of the two instances:

    RelayBase relaySocket.getLocalPort=50582 relayServer=109.74.203.226 relayPort=18771y
    RelayBase receiveHandler send encrypted initialMsg='...'
    RelayBase connectedThread send='data'
    RelayBase connectedThread finished
    RelayBase receiveMsgHandler 'data'; setting relayQuitFlag
    
The two instances match by telling the relay server to connect each other with another instance by the same advertised name 'RelayBase'.

### RelayStress

    ./run timur.p2pCore.RelayStress

RelayStress works like RelayBase, but it sends "data" 5000 times before it sends "last" to signal end of communication. RelayStress has about 25 lines of code. RelayStress uses a relayed communication path like RelayBase. When you see this in the console, then all 5000 data elements have been send and also 5000 data elements from the other instance have been received:

    RelayStress relaySocket.getLocalPort=51626 relayServer=109.74.203.226 relayPort=18771
    RelayStress receiveHandler send encrypted initialMsg='...'
    RelayStress connectString finished sending; relayQuitFlag=false
    RelayStress receiveMsgHandler last; relayQuitFlag=false
    RelayStress relayExit outgoingDataCounter=5000 incomingDataCounter=5000
The two instances match by telling the relay server to connect each other with another instance by the same advertised name 'RelayStress'.

### P2pBase

    ./run timur.p2pCore.P2pBase

P2pBase works like RelayBase, but instead of using a relay server to route communications, a direct p2p link will be established between the two client instances. Client ask the relay server to match them with another instance using the same name 'P2pBase'. The relay server is being used only to match the two clients and to help them learn about their public adresses and port numbers. All other communication is happening directly from client to client.

    P2pBase relaySocket.getLocalPort=48564 relayServer=109.74.203.226 relayPort=18771
    P2pBase receiveHandler send encrypted initialMsg='...'
    P2pBase combinedUdpAddrString this peer udpAddress=89.201.71.60:60177|192.168.1.135:60177
    P2pBase receiveMsgHandler other peer combindedUdpAddress=89.201.71.60:51556|192.168.1.135:51556
    P2pBase datagramSendThread udpIpAddr='89.201.71.60' udpPortInt=51556 connected
    P2pBase datagramSendThread udpIpAddr='192.168.1.135' udpPortInt=51556 abort
    P2pBase p2pReceiveHandler str='hello 0'
    P2pBase p2pReceiveHandler str='hello 1'
    P2pBase p2pReceiveHandler str='hello 2'


### P2pEncrypt

    ./run timur.p2pCore.P2pEncrypt keysAlice bob
    ./run timur.p2pCore.P2pEncrypt keysBob alice

P2pEncrypt works like P2pBase, but all client to client data will be encrypted. In addition, the fingerprint of the selected remote public key is used to match the clients. P2pEncrypt needs two arguments: 1. the name of the folder containing the remote public keys. And 2. the name of the public key to which a connection shall be established.

    P2pEncrypt fullLocalKeyName=keysAlice/key.pub used for fingerprint matching
    P2pEncrypt fullRemoteKeyName=keysAlice/bob.pub used for fingerprint matching
    P2pEncrypt relaySocket.getLocalPort=48878 relayServer=109.74.203.226 relayPort=18771
    P2pEncrypt receiveHandler send encrypted initialMsg='...'
    P2pEncrypt combinedUdpAddrString this peer udpAddress=89.201.71.60:34570|192.168.1.135:34570
    P2pEncrypt receiveMsgHandler other peer combindedUdpAddress='89.201.71.60:54413|192.168.1.135:54413'
    P2pEncrypt datagramSendThread udpIpAddr='192.168.1.135' udpPortInt=54413 abort
    P2pEncrypt datagramSendThread udpIpAddr='89.201.71.60' udpPortInt=54413 connected
    P2pEncrypt p2pReceiveHandler decryptString='hello 0'
    P2pEncrypt p2pReceiveHandler decryptString='hello 1'
    P2pEncrypt p2pReceiveHandler decryptString='hello 2'

Rendesvouz string matching can be used as an alternative to fingerprint matching:

    ./run timur.p2pCore.P2pEncrypt keysAlice - rendesvouz
    ./run timur.p2pCore.P2pEncrypt keysBob - rendesvouz
    
In this case, P2pEncrypt requires three arguments: 1. the name of the folder containing the remote public keys. 2. a dash to indicate that no key shall be used for client matching. 3. a unique matching string. Both clients need to enter the exact same string, in order to get mached. The advantage of using random Rendesvouz strings for matching, is that the relay server will not see any key fingerprints and therefor has no means to identify who is sending the request.

    P2pEncrypt fullLocalKeyName=keysBob/key.pub used for fingerprint matching
    P2pEncrypt matching clients with rendezvous string 'rendesvouz'
    P2pEncrypt relaySocket.getLocalPort=48884 relayServer=109.74.203.226 relayPort=18771
    P2pEncrypt receiveHandler send encrypted initialMsg='...'
    P2pEncrypt combinedUdpAddrString this peer udpAddress=89.201.71.60:46347|192.168.1.135:46347
    P2pEncrypt receiveMsgHandler other peer combindedUdpAddress='89.201.71.60:40939|192.168.1.135:40939'
    P2pEncrypt datagramSendThread udpIpAddr='89.201.71.60' udpPortInt=40939 connected
    P2pEncrypt datagramS endThread udpIpAddr='192.168.1.135' udpPortInt=40939 abort
    P2pEncrypt requestPubKeyFingerprint...
    P2pEncrypt sending fingerprint of our pubkey on request=5453889C95BDB4703CE7D83E6DEACA8F7E3774DB
    P2pEncrypt p2pReceiveHandler: remoteKeyFingerprint=0B40B89E4BE4F94BF2609F0EB522F693466FC14F
    P2pEncrypt found stored pubKeyRemote in file alice.pub
    P2pEncrypt p2pReceiveHandler decryptString='hello 0'
    P2pEncrypt p2pReceiveHandler decryptString='hello 1'
    P2pEncrypt p2pReceiveHandler decryptString='hello 2'

Fingerprints are exchanged as soon as the direct p2p link becomes available and are immediately being used to fetch the required public key, needed to start back to back encryption with the other party.


More info
---------

- protobuf folder 
  (todo:) 

- bouncy-jarjar and bcprov-jdk15on-147.jar 
  (todo:) 

- keys* folders 
  (todo:) 

- getjars 
  (todo:) 

- relaykey.pub 
  (todo:) 

- the role of the relayserver 
  (todo:) 


License
-------

Source code is licensed under the GNU General Public License, Version 3

Copyright (C) 2012 timur.mehrvarz@gmail.com

3rd party libraries being used:

- Bouncycastele

- Google protobuf

- Apache commons-codec

- JarJar


Todo
----

- RelayEncrypt out-of-date needs fix; still using "keys/key0" "keys/key0.pub"
- ./run timur.p2pCore.RelayBench needs fix: "print duration time"


